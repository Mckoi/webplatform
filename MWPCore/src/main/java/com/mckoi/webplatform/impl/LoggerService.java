/**
 * com.mckoi.webplatform.LoggerService  Jul 25, 2010
 *
 * Mckoi Database Software ( http://www.mckoi.com/ )
 * Copyright (C) 2000 - 2012  Diehl and Associates, Inc.
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 3 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with this program.  If not, see ( http://www.gnu.org/licenses/ ) or
 * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA  02111-1307, USA.
 *
 * Change Log:
 *
 *
 */

package com.mckoi.webplatform.impl;

import com.mckoi.mwpcore.DBSessionCache;
import com.mckoi.network.CommitFaultException;
import com.mckoi.odb.ODBClass;
import com.mckoi.odb.ODBList;
import com.mckoi.odb.ODBObject;
import com.mckoi.odb.ODBTransaction;
import com.mckoi.webplatform.LogPageEvent;
import com.mckoi.webplatform.MWPRuntimeException;
import com.mckoi.webplatform.MckoiDDBWebPermission;
import java.util.*;
import java.util.logging.Level;

/**
 * An object that parses buckets of log messages generated by nodes on the
 * network and stores them in appropriate indexes in the system log path.
 * The log processing operation may be required to process a lot of data so
 * the system is scalable.
 * <p>
 * A LoggerService is unique to a web app context running on a server. There may
 * be multiple log servers running on different nodes so should permit
 * concurrent operations.
 *
 * @author Tobias Downer
 */

public final class LoggerService {

  /**
   * The permission for creating a logger service.
   */
  private final static MckoiDDBWebPermission ACCESS_LOGGER_SERVICE =
                             new MckoiDDBWebPermission("loggerService.access");

  /**
   * The session cache.
   */
  private final DBSessionCache sessions_cache;

  /**
   * The log_path where the log events are written to.
   */
  private final String log_path;

  /**
   * The system timer used to schedule log flushes.
   */
  private final Timer system_timer;

  /**
   * The map of events to log page handlers.
   */
  private final Map<String, LogPage> event_handlers;

  private boolean is_started = false;

  
  private final Object SCHED_LOCK = new Object();
  private TimerTask flush_task;


  /**
   * Constructor. Generates a SecurityException if stack frame not permitted
   * to create/start or stop this.
   * @param sessions_cache
   * @param log_path
   * @param system_timer
   */
  public LoggerService(DBSessionCache sessions_cache,
                      String log_path, Timer system_timer) {
    checkSecurity();
    this.sessions_cache = sessions_cache;
    this.log_path = log_path;
    this.system_timer = system_timer;
    this.event_handlers = new HashMap<>();
  }

  /**
   * Checks security manager to make sure the thread context has permission to
   * create, start and stop this service.
   */
  private void checkSecurity() {
    // Check with security that we can create this,
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
      security.checkPermission(ACCESS_LOGGER_SERVICE);
    }
  }


  /**
   * Forces the log to flush out to the database.
   */
  public void forceFlush() {
    checkSecurity();

    // Cancel the task,
    TimerTask the_task = null;
    synchronized (SCHED_LOCK) {
      if (flush_task != null) {
        flush_task.cancel();
        the_task = flush_task;
        flush_task = null;
      }
    }

    // Run the task,
    if (the_task != null) {
      the_task.run();
    }

  }

  /**
   * Throws an exception if the log name is invalid.
   */
  static void checkLogName(String log_name) {
    if (log_name.length() > 30) {
      throw new MWPRuntimeException("Log name too large");
    }
    else if (log_name.contains("=")) {
      throw new MWPRuntimeException("Log name contains invalid character");
    }
  }

  /**
   * The log flush timed task.
   */
  private class LogFlushTask extends TimerTask {
    @Override
    public void run() {

      // Clean the flush task,
      synchronized (SCHED_LOCK) {
        flush_task = null;
      }

      try {
        ArrayList<LogPage> log_pages = new ArrayList<>();
        ArrayList<String> log_types = new ArrayList<>();
        synchronized (event_handlers) {
          for (String log_type : event_handlers.keySet()) {
            LogPage log_page = event_handlers.get(log_type);
            long first_timestamp = log_page.getFirstTimestamp();
            // If there's something in the log page and it happened longer than
            // 30 seconds ago, then flush the page,
            if (first_timestamp > -1) {
              // Add to the log pages list and remove from the map,
              log_pages.add(log_page);
              log_types.add(log_type);
            }
          }

          // Remove them from the map,
          for (String log_type : log_types) {
            event_handlers.remove(log_type);
          }

        }

        // PENDING: If we failed to flush logs the pages need to be added into
        //  a 'retry' log.

        // Flush these pages,
        if (log_pages.size() > 0) {
          LogPage[] page_arr = log_pages.toArray(new LogPage[log_pages.size()]);
          // Flush
          flushPages(page_arr);
        }
      }
      catch (Throwable e) {
        // Ignore, print to system console,
        e.printStackTrace(System.err);
      }

    }
  }

  /**
   * Flushes a LogPage out to the log files stored in the given transaction.
   * <p>
   * This does not commit the transaction. Returns the name of the log page
   * file created.
   */
  private void flushLogPageTo(LogPage log_page,
                              ODBTransaction transaction) {

    // The type of log,
    String log_type = log_page.getLogType();

    // The log class,
    ODBClass log_class = transaction.findClass("L.Log");
    ODBClass word_class = transaction.findClass("L.Word");
    ODBClass entry_class = transaction.findClass("L.Entry");

    // The log root,
    ODBObject log_root = transaction.getNamedItem("logroot");

    // Find the log type from the root,
    ODBList logs_list = log_root.getList("logs");

    // Get the log object for the type,
    ODBObject log_ob = logs_list.getObject(log_type);
    // If it doesn't exist, create it,
    if (log_ob == null) {
      // (name, entries, dict_word, dict_ref)
      log_ob = transaction.constructObject(log_class,
                                           log_type, null, null, null);
      // Add the log object to the list,
      logs_list.add(log_ob);
    }

    // The entries,
    ODBList entries = log_ob.getList("entries");

    // The dictionary for this type,
    ODBList dict_word = log_ob.getList("dict_word");
    ODBList dict_ref = log_ob.getList("dict_ref");

    // Write the log entries out. A value is only written out once. Nulls
    // are a special case.
    List<LogPageEventImpl> log_page_events = log_page.getEvents();
    // For each event in the page,
    for (LogPageEventImpl evt : log_page_events) {
      // The timestamp of the event,
      long timestamp = evt.getTimestamp();
      String v1 = Long.toString(timestamp, 32);
      String time_uid = SecureRandomUtil.pad(v1, 14);

      // The event encoded as a string value,
      StringBuilder e = new StringBuilder();

      int sz = evt.getValueCount();

      // Encode the number of entries,
      e.append(Integer.toString(sz, 32));

      // For each value in the event,
      for (int i = 0; i < sz; ++i) {
        // The entry value,
        String val = evt.getValue(i);
        // If it's null,
        if (val == null) {
          // (1 character)
          e.append('#');
        }
        // If it's empty string,
        else if (val.length() == 0) {
          // (1 character)
          e.append('-');
        }
        // Not null,
        else {
          // If the size of the value is greater than 33 then it could be in
          // the dictionary,
          ODBObject word = null;
          int val_length = val.length();
          if (val_length > 33) {
            // Is the word in the dictionary?
            word = dict_word.getObject(val);
            // If it's not, should we make a dictionary entry?
            if (word == null) {
              // If the value was repeated more than four times in the page we
              // put it in the dictionary,
              if (log_page.getWordRepetitions(val) > 4) {
                word = transaction.constructObject(word_class, val);
                dict_word.add(word);
                dict_ref.add(word);
              }
            }
          }

          // If it's a dictionary reference,
          if (word != null) {
            // 33 characters
            e.append('*');
            e.append(word.getReference().toString());
          }
          // Otherwise the word value encoding,
          else {
            // Min=4 characters
            e.append('[');
            e.append(Integer.toString(val.length(), 32));
            e.append(']');
            e.append(val);
          }
        }
      }

      // Create the entry object,
      // (time, value)
      ODBObject entry_ob = transaction.constructObject(entry_class,
              time_uid, e.toString());

      // Add the entry to the log object,
      entries.add(entry_ob);

    }

  }

  /**
   * Flushes all the pages out to the log path.
   */
  private void flushPages(LogPage[] pages) {
    ODBTransaction transaction = sessions_cache.getODBTransaction(log_path);

    // Flush all the log pages,
    for (LogPage page : pages) {
      flushLogPageTo(page, transaction);
    }

    // Commit the changes,
    try {
      transaction.commit();
    }
    catch (CommitFaultException e) {
      // TODO: Write the pages to the local disk on a commit fault?
      throw new MWPRuntimeException(e);
    }
  }

  /**
   * Outputs a message to the event log for the given handler (for example,
   * handler = 'webapp' outputs to the account's web app log).
   */
  void log(String log_type, LogPageEventImpl event) {

    LogPage to_flush = null;

    // Get the current log page for the given log type,
    synchronized (event_handlers) {
      LogPage log_page = event_handlers.get(log_type);
      if (log_page == null) {
        log_page = new LogPage(log_type);
        event_handlers.put(log_type, log_page);
      }
      // Add the event to the log,
      log_page.addEvent(event);
      // If there are 1024 or more events in the log, flush it to the path,
      if (log_page.getSize() >= 1024) {
        to_flush = log_page;
        // Remove the page from the handlers,
        event_handlers.remove(log_type);
      }
    }

    // Flush this page,
    if (to_flush != null) {
      flushPages(new LogPage[] { to_flush });
    }
    // Schedule a flush event,
    else {
      // Schedule the flush 30 seconds from now,
      synchronized (SCHED_LOCK) {
        if (flush_task == null) {
          flush_task = new LogFlushTask();
          system_timer.schedule(flush_task, (30 * 1000));
        }
      }
    }

  }

  /**
   * Outputs a message to the event log for the given handler (for example,
   * handler = 'webapp' outputs to the account's web app log).
   */
  LogPageEvent log(Level lvl, String log_type, String message, String... args) {

    int arg_count = args.length;

    // Create the log message,
    LogPageEventImpl event = new LogPageEventImpl(
                                    System.currentTimeMillis(), arg_count + 1);
    event.setValue(0, message);
    for (int i = 0; i < arg_count; ++i) {
      event.setValue(i + 1, args[i]);
    }
    log(log_type, event);

    return event;

  }

  /**
   * Same as 'log' only there's a security check.
   * 
   * @param level
   * @param log_type
   * @param message
   * @param args
   * @return 
   */
  public LogPageEvent secureLog(Level level, String log_type,
                                String message, String... args) {

    checkSecurity();
    return log(level, log_type, message, args);

  }

}
